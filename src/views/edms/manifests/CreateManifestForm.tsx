'use client'

import { useState, useEffect } from 'react'
import { useRouter } from 'next/navigation'
import {
  Card,
  CardHeader,
  CardContent,
  Grid,
  TextField,
  Select,
  MenuItem,
  FormControl,
  InputLabel,
  Button,
  Box,
  Typography,
  Chip,
  Divider,
  Alert,
  Autocomplete
} from '@mui/material'
import { DatePicker } from '@mui/x-date-pickers/DatePicker'
import { LocalizationProvider } from '@mui/x-date-pickers/LocalizationProvider'
import { AdapterDayjs } from '@mui/x-date-pickers/AdapterDayjs'
import dayjs, { Dayjs } from 'dayjs'

// Type Imports
import { ManifestType } from '@/types/apps/deliveryTypes'
import { VehicleType } from '@/types/apps/deliveryTypes'
import { PickupLocationType, DropoffLocationType } from '@/types/apps/deliveryTypes'

// Action Imports
import { createManifest } from '@/libs/actions/manifest.actions'
import { getAllPickupLocations } from '@/libs/actions/location.actions'
import { getAllDropoffLocations } from '@/libs/actions/location.actions'

const CreateManifestForm = () => {
  const router = useRouter()
  const [loading, setLoading] = useState(false)
  const [error, setError] = useState('')
  const [success, setSuccess] = useState('')

  // Form state
  const [formData, setFormData] = useState({
    vehicle: '',
    driver: '',
    pickupLocation: '',
    dropoffLocation: '',
    manifestDate: dayjs(),
    packages: [] as string[],
    packageTypes: {
      small: 0,
      medium: 0,
      large: 0,
      bins: 0
    },
    notes: '',
    creator: 'current-user' // This should come from auth context
  })

  // Data for dropdowns
  const [pickupLocations, setPickupLocations] = useState<PickupLocationType[]>([])
  const [dropoffLocations, setDropoffLocations] = useState<DropoffLocationType[]>([])
  const [vehicles] = useState<VehicleType[]>([]) // TODO: Implement vehicle fetching
  const [drivers] = useState<any[]>([]) // TODO: Implement driver fetching

  // Fetch data on component mount
  useEffect(() => {
    const fetchData = async () => {
      try {
        const [pickupLocs, dropoffLocs] = await Promise.all([
          getAllPickupLocations(),
          getAllDropoffLocations()
        ])
        
        setPickupLocations(pickupLocs)
        setDropoffLocations(dropoffLocs)
      } catch (error) {
        console.error('Error fetching data:', error)
        setError('Failed to load locations')
      }
    }

    fetchData()
  }, [])

  const handleInputChange = (field: string, value: any) => {
    setFormData(prev => ({
      ...prev,
      [field]: value
    }))
    setError('')
  }

  const handlePackageTypeChange = (type: keyof typeof formData.packageTypes, value: number) => {
    setFormData(prev => ({
      ...prev,
      packageTypes: {
        ...prev.packageTypes,
        [type]: Math.max(0, value)
      }
    }))
  }

  const calculateTotalPackages = () => {
    return Object.values(formData.packageTypes).reduce((sum, count) => sum + count, 0)
  }

  const validateForm = () => {
    if (!formData.vehicle) return 'Vehicle is required'
    if (!formData.driver) return 'Driver is required'
    if (!formData.pickupLocation) return 'Pickup location is required'
    if (!formData.dropoffLocation) return 'Dropoff location is required'
    if (!formData.manifestDate) return 'Manifest date is required'
    if (calculateTotalPackages() === 0) return 'At least one package is required'
    
    return null
  }

  const handleSubmit = async () => {
    const validationError = validateForm()
    if (validationError) {
      setError(validationError)
      return
    }

    setLoading(true)
    setError('')

    try {
      const manifestData: Omit<ManifestType, '$id' | '$createdAt' | '$updatedAt'> = {
        manifestNumber: `MF-${Date.now()}`, // Temporary, will be regenerated by action
        trip: '', // Will be set when assigned to a trip
        vehicle: formData.vehicle,
        driver: formData.driver,
        pickuplocation: formData.pickupLocation,
        dropofflocation: formData.dropoffLocation,
        dropoffSequence: 1, // Default sequence, will be updated when added to trip
        manifestDate: formData.manifestDate.toISOString(),
        totalPackages: calculateTotalPackages(),
        packageTypes: JSON.stringify(formData.packageTypes), // Convert to JSON string for database
        packages: formData.packages,
        status: 'pending',
        notes: formData.notes,
        deliveryGpsVerified: false,
        deliveredPackages: JSON.stringify([]),
        missingPackages: JSON.stringify([]),
        creator: formData.creator
      }

      await createManifest(manifestData)
      setSuccess('Manifest created successfully!')
      
      // Redirect to manifests list after success
      setTimeout(() => {
        router.push('/edms/manifests')
      }, 2000)
      
    } catch (error) {
      console.error('Error creating manifest:', error)
      setError('Failed to create manifest. Please try again.')
    } finally {
      setLoading(false)
    }
  }

  const handleCancel = () => {
    router.push('/edms/manifests')
  }

  return (
    <LocalizationProvider dateAdapter={AdapterDayjs}>
      <Card>
        <CardHeader
          title="Create New Manifest"
          subheader="Fill in the details to create a new delivery manifest"
        />
        <CardContent>
          {error && (
            <Alert severity="error" className="mb-4">
              {error}
            </Alert>
          )}
          
          {success && (
            <Alert severity="success" className="mb-4">
              {success}
            </Alert>
          )}

          <Grid container spacing={4}>
            {/* Basic Information */}
            <Grid item xs={12}>
              <Typography variant="h6" gutterBottom>
                Basic Information
              </Typography>
              <Divider className="mb-4" />
            </Grid>

            <Grid item xs={12} sm={6}>
              <DatePicker
                label="Manifest Date"
                value={formData.manifestDate}
                onChange={(date) => handleInputChange('manifestDate', date)}
                slotProps={{
                  textField: {
                    fullWidth: true,
                    required: true
                  }
                }}
              />
            </Grid>

            <Grid item xs={12} sm={6}>
              <TextField
                fullWidth
                label="Notes"
                value={formData.notes}
                onChange={(e) => handleInputChange('notes', e.target.value)}
                multiline
                rows={2}
                placeholder="Any special instructions or notes..."
              />
            </Grid>

            {/* Route Information */}
            <Grid item xs={12}>
              <Typography variant="h6" gutterBottom className="mt-4">
                Route Information
              </Typography>
              <Divider className="mb-4" />
            </Grid>

            <Grid item xs={12} sm={6}>
              <Autocomplete
                options={pickupLocations}
                getOptionLabel={(option) => `${option.locationName} (${option.locationCode})`}
                value={pickupLocations.find(loc => loc.$id === formData.pickupLocation) || null}
                onChange={(_, value) => handleInputChange('pickupLocation', value?.$id || '')}
                renderInput={(params) => (
                  <TextField
                    {...params}
                    label="Pickup Location"
                    required
                    fullWidth
                  />
                )}
                renderOption={(props, option) => (
                  <Box component="li" {...props}>
                    <Box>
                      <Typography variant="body2">{option.locationName}</Typography>
                      <Typography variant="caption" color="text.secondary">
                        {option.address}, {option.city}
                      </Typography>
                    </Box>
                  </Box>
                )}
              />
            </Grid>

            <Grid item xs={12} sm={6}>
              <Autocomplete
                options={dropoffLocations}
                getOptionLabel={(option) => `${option.locationName} (${option.locationCode})`}
                value={dropoffLocations.find(loc => loc.$id === formData.dropoffLocation) || null}
                onChange={(_, value) => handleInputChange('dropoffLocation', value?.$id || '')}
                renderInput={(params) => (
                  <TextField
                    {...params}
                    label="Dropoff Location"
                    required
                    fullWidth
                  />
                )}
                renderOption={(props, option) => (
                  <Box component="li" {...props}>
                    <Box>
                      <Typography variant="body2">{option.locationName}</Typography>
                      <Typography variant="caption" color="text.secondary">
                        {option.address}, {option.city}
                      </Typography>
                    </Box>
                  </Box>
                )}
              />
            </Grid>

            {/* Assignment */}
            <Grid item xs={12}>
              <Typography variant="h6" gutterBottom className="mt-4">
                Assignment
              </Typography>
              <Divider className="mb-4" />
            </Grid>

            <Grid item xs={12} sm={6}>
              <FormControl fullWidth required>
                <InputLabel>Vehicle</InputLabel>
                <Select
                  value={formData.vehicle}
                  onChange={(e) => handleInputChange('vehicle', e.target.value)}
                  label="Vehicle"
                >
                  {vehicles.length === 0 && (
                    <MenuItem disabled>
                      <em>No vehicles available</em>
                    </MenuItem>
                  )}
                  {vehicles.map((vehicle) => (
                    <MenuItem key={vehicle.$id} value={vehicle.$id}>
                      {vehicle.vehicleNumber} - {vehicle.vehicleType}
                    </MenuItem>
                  ))}
                </Select>
              </FormControl>
            </Grid>

            <Grid item xs={12} sm={6}>
              <FormControl fullWidth required>
                <InputLabel>Driver</InputLabel>
                <Select
                  value={formData.driver}
                  onChange={(e) => handleInputChange('driver', e.target.value)}
                  label="Driver"
                >
                  {drivers.length === 0 && (
                    <MenuItem disabled>
                      <em>No drivers available</em>
                    </MenuItem>
                  )}
                  {drivers.map((driver) => (
                    <MenuItem key={driver.$id} value={driver.$id}>
                      {driver.name} - {driver.phone}
                    </MenuItem>
                  ))}
                </Select>
              </FormControl>
            </Grid>

            {/* Package Information */}
            <Grid item xs={12}>
              <Typography variant="h6" gutterBottom className="mt-4">
                Package Information
              </Typography>
              <Divider className="mb-4" />
            </Grid>

            <Grid item xs={12} sm={3}>
              <TextField
                fullWidth
                type="number"
                label="Small Packages"
                value={formData.packageTypes.small}
                onChange={(e) => handlePackageTypeChange('small', parseInt(e.target.value) || 0)}
                InputProps={{ inputProps: { min: 0 } }}
              />
            </Grid>

            <Grid item xs={12} sm={3}>
              <TextField
                fullWidth
                type="number"
                label="Medium Packages"
                value={formData.packageTypes.medium}
                onChange={(e) => handlePackageTypeChange('medium', parseInt(e.target.value) || 0)}
                InputProps={{ inputProps: { min: 0 } }}
              />
            </Grid>

            <Grid item xs={12} sm={3}>
              <TextField
                fullWidth
                type="number"
                label="Large Packages"
                value={formData.packageTypes.large}
                onChange={(e) => handlePackageTypeChange('large', parseInt(e.target.value) || 0)}
                InputProps={{ inputProps: { min: 0 } }}
              />
            </Grid>

            <Grid item xs={12} sm={3}>
              <TextField
                fullWidth
                type="number"
                label="Bins"
                value={formData.packageTypes.bins}
                onChange={(e) => handlePackageTypeChange('bins', parseInt(e.target.value) || 0)}
                InputProps={{ inputProps: { min: 0 } }}
              />
            </Grid>

            <Grid item xs={12}>
              <Box display="flex" alignItems="center" gap={2}>
                <Typography variant="body1">
                  Total Packages: 
                </Typography>
                <Chip 
                  label={calculateTotalPackages()} 
                  color={calculateTotalPackages() > 0 ? 'primary' : 'default'}
                />
              </Box>
            </Grid>

            {/* Actions */}
            <Grid item xs={12}>
              <Box display="flex" gap={2} justifyContent="flex-end" className="mt-6">
                <Button
                  variant="outlined"
                  onClick={handleCancel}
                  disabled={loading}
                >
                  Cancel
                </Button>
                <Button
                  variant="contained"
                  onClick={handleSubmit}
                  disabled={loading}
                >
                  {loading ? 'Creating...' : 'Create Manifest'}
                </Button>
              </Box>
            </Grid>
          </Grid>
        </CardContent>
      </Card>
    </LocalizationProvider>
  )
}

export default CreateManifestForm